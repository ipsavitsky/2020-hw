# Решение таска p01

## Задание 10

> Проверьте, выполняется ли правило "ленивых вычислений" выражений в Си, т.е. прекращается ли вычисление выражений с логическими операциями, если возможно "досрочно" установить значение результата.

_Ленивые вычисления_: стратегия вычисления которая гласит, что вычисления надо откладывать до тех пор, пока не понадобится их результат(определение адаптировано [отсюда](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)). Грубо говоря, самое большое преимущество таких вычислений состоит в том, что вычсисления результат которых не понадобится никогда не произойдут.

Для проверки того, выполняются ли в языке Си такие вычисления была написана следующая программа:

**task_10.c**

```c
#include <stdio.h>

int check(void){
    printf("lazy evaluation DOES NOT WORK!! ABANDON SHIP!!!\n");
    return 1;
}

int main(void){
    printf("%d\n", 0 && check());
    return 0;
}
```

В `printf()` в функции `main()` стоит логическое выражение `0 && check()`. Если ленивые вычисления работают, то функция `check()` никогда и не вызовится потому что результат операции `&&` уже детерменирован нулем. Нетрудно проверить, что так и есть. Программа выводит:

```
0
```

Метод проверки был взят [отсюда](https://habr.com/ru/post/247213/)

## Задание 18

> Определите, каким образом при выполнении операции присваивания и явном приведении происходит преобразование беззнаковых целых (M-битовое представление) к беззнаковым целым (N-битовое представление) при M > N, M = N, M < N.

Рассмотрим три случая явного приведения беззнаковых целых. Для каждого из них запустим диссасемблер:

```
gcc -g -c test.c
objdump -d -M intel -S test.o
```
О том, как я до этого дошел можно прочитать [тут](https://stackoverflow.com/questions/137038/how-do-you-get-assembler-output-from-c-c-source-in-gcc)

(можно сразу сделать вывод при помощи `gcc -S -fverbose-asm -masm=intel test.c`, однако дисассемблер дает более "чистый" вывод с которым проще работать, хотя на всякий случай я перепроверил)

Некоторые части этих преобразований могут зависеть от компилятора, поэтому, на всякий случай, укажу версию компилятора

```
gcc version 9.3.0 (Ubuntu 9.3.0-10ubuntu2)
```

Для каждого пункта в условии рассмотрим вывод дисассемблера:

---

- `M > N`

**task_18_1.c**

```c
int main(void){
	unsigned long int i = 15;
	unsigned int j = (int)i;
	return 0;
}
```

**task_18_1.s**

```asm
    ;int main(void){
    endbr64
    push   rbp
    mov    rbp,rsp
    ;long int i = 15;
    mov    QWORD PTR [rbp-0x8],0xf
    ;int j = i;
    ;---------------------------------
    mov    rax,QWORD PTR [rbp-0x8]   ;
    mov    DWORD PTR [rbp-0xc],eax   ;
    ;---------------------------------
    ;return 0;
    mov    eax,0x0
    ;}
    pop    rbp
    ret
```

(На всякий случай, добавим случай в котором значение в изначальной переменной не поместится в конечную переменную)

**task_18_2.c**

```c
#include <stdio.h>

int main(void){
	unsigned long int i = 4294967295;
	unsigned int j = (int)i;
	return 0;
}
```

**task_18_2.s**

```asm
    ;int main(void){
    endbr64
    push   rbp
    mov    rbp,rsp
    ;unsigned long int i = 4294967295;
    mov    eax,0xffffffff
    mov    QWORD PTR [rbp-0x8],rax
    ;unsigned int j = (int)i;
    ;---------------------------------
    mov    rax,QWORD PTR [rbp-0x8]   ;
    mov    DWORD PTR [rbp-0xc],eax   ;
    ;---------------------------------
    ;return 0;
    mov    eax,0x0
    pop    rbp
    ret
```

---

- `M = N`

**task_18_3.c**

```c
#include <stdio.h>

int main(void){
unsigned int i = 15;
unsigned int j = (int)i;
return 0;
}
```

**task_18_3.s**

```asm
   ;int main(void){
   endbr64
   push   rbp
   mov    rbp,rsp
   ;unsigned int i = 15;
   mov    DWORD PTR [rbp-0x8],0xf
   ;unsigned int j = (int)i;
   ;---------------------------------
   mov    eax,DWORD PTR [rbp-0x8]   ;
   mov    DWORD PTR [rbp-0x4],eax   ;
   ;---------------------------------
   ;return 0;
   mov    eax,0x0
   ;}
   pop    rbp
   ret
```

---

- `M < N`

**task_18_4.c**

```c
#include <stdio.h>

int main(void){
unsigned int i = 15;
unsigned long int j = (long int)i;
return 0;
}
```

**task_18_4.s**

```asm
   ;int main(void){
   endbr64
   push   rbp
   mov    rbp,rsp
   ;unsigned int i = 15;
   mov    DWORD PTR [rbp-0xc],0xf
   ;unsigned long int j = (long int)i;
   ;---------------------------------
   mov    eax,DWORD PTR [rbp-0xc]   ;
   mov    QWORD PTR [rbp-0x8],rax   ;
   ;---------------------------------
   ;return 0;
   mov    eax,0x0
   ;}
   pop    rbp
   ret
```

---

Очевидно, что преобразование целых типов данный компилятор производит тем, что при помощи `DWORD PTR` И `QWORD PTR`(потому что для тестирования были выбраны `int` и `long int` размером 4 и 8 байт соответственно) берет участки памяти разного размера(это видно в выделенных участках ассемблерного кода). При приведении большего типа к меньшему компилятор берет младшие биты, а старшие "обрубает"
Также, это можно подтвердить при помощи следующих функций:

**bit_test.c**

```c
#include <stdio.h>

void bitprint_short(unsigned short input){
    unsigned short mask = 1 << 15;
    while(mask != 0){
        // printf("%d\n", mask);
        printf("%d", (input & mask) == 0 ? 0 : 1);
        mask = mask >> 1;
    }
}

void bitprint_int(unsigned int input){
    unsigned int mask = 1 << 31;
    while (mask != 0){
        // printf("%d", mask);
        printf("%d", (input & mask) == 0 ? 0 : 1);
        mask = mask >> 1;
    }
}
```

Можно побитово вывести типы `unsigned int` и `unsigned short` для того, чтобы проверить как они расширяются до других беззнаковых целых типов (эх, сюда бы шаблонные функции, но, видимо, не судьба).
Вызывая эти функции с разными аргументами и в разном порядке можно получить результаты для всех трех случаев. Например, при помощи

```c
int main(void){
    unsigned short k = 256;
    printf("short = %ld bytes\n", sizeof(short));
    printf("int = %ld bytes\n", sizeof(int));
    bitprint_short(k);
    printf("\n");
    bitprint_int((unsigned int)k);
    printf("\n");
    return 0;
}
```

проверяется расширение типа `unsigned short` в `unsigned int`(случай `M < N`). Остальные примеры я приводить не стал, чтобы не захламлять этот отчет еще сильнее, но логика в построении `main()` следующая: 
1. Создание переменной размера M
2. Вызов соответствующего типу M `bitprint_XXX()`
3. Вызов `bitprint_YYY()`, соответствующий типу N, с приведенной к типу N переменной в качестве параметра.

Далее приводятся примеры ввода/вывода комбинаций вызова этих функций:

---

- `M < N`

(проверка на числе 256)

```
0000000100000000
00000000000000000000000100000000
```

---

- `M = N`

(проверка на числе 64)

```
0000000001000000
0000000001000000
```

---

- `M > N`

(тут я пропустил тот вариант в котором число из M помещается в N потому что его исход очевиден)

(проверка на числе 4294907295)

```
11111111111111110001010110011111
0001010110011111
```

---

Итого видно, что предположение о том, что беззнаковые типы расширяются при помощи того, что компилятор просто "берет" память разного размера для переменных разного размера, остается верной.